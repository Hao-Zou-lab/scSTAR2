#' permutation test
#'
#' @param model matrix input.
#' @param X input data matrix.
#' @param Y response variable matrix.
#' @param nc Number of Components.
#' @param ncox Number of Orthogonalization components for X data.
#' @param ncoy Number of Orthogonalization components for Y data.
#' @param nrcv Number of cross-validation components for the model.
#' @param np Number of permutation tests to perform.
#'
#' @return PTQ2,This output is a vector of Q2 values generated by the permutation test and is used to evaluate the significance of the model Q2 values.


PT <- function(model, X, Y, nc, ncox, ncoy, nrcv, np) {
  # permutation test to generate random Q2

  buffer_Q2 <- numeric(1)
  buffer_Q2[1] <- model$Q2Yhatcum
  a <- numeric(np + 1)
  b <- numeric(np + 1)
  c <- numeric(np + 1)
  a[1] <- 1
  b[1] <- model$Q2Yhatcum
  c[1] <- model$R2Yhat[length(model$R2Yhat)]
  for (j in 1:np) {
    ns <- nrow(Y)
    p <- sample(1:ns)
    Y_perm <- Y
    Y_perm[1:floor(0.8 * ns), ] <- Y[unlist(p[1:floor(0.8 * ns)]),, drop = FALSE ]
    Y_col1 <- Y[, 1]
    Y_perm_col1 <- Y_perm[, 1]
    #R2 <- cor(cbind(Y_col1, Y_perm_col1))^2
    
    model <- o2pls_m(X, Y_perm, nc, ncox, ncoy, nrcv, 0)
    
    Q2 <- model$Q2Yhatcum
    #model <- o2pls_m(X, Y_perm, nc, ncox, ncoy, 0, 0)
    #a[j + 1] <- R2[1, 2]
    b[j + 1] <- Q2
    #c[j + 1] <- model$R2Yhat[length(model$R2Yhat)]
    buffer_Q2[j + 1] <- Q2
   
    }
  avePTQ2 <- median(b[-1])
  PTQ2 <- b[-1]
  PT_Q <- list(avePTQ2=avePTQ2,PTQ2=PTQ2)
  return(PT_Q)
}
